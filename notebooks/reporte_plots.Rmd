---
title: "reporte_plots"
output: html_document
---

# Introducción
Este reporte presenta avances al análisis de detección de irregularidades en el Padrón Único de beneficiarios. 


```{r, echo=FALSE, results='hide', include=FALSE}
options(scipen=10000)

dotenv::load_dot_env("../.env")
paquetines <- c("dbrsocial","ggplot2","tidyverse","plyr","scales",
                "maptools","rgdal","ggmap","gridExtra","rgdal",
                "Hmisc","rgeos","sp","sf","rgeos","broom","scales",
                "rangeMapper","ggmap","plotly","viridis")
no_instalados <- paquetines[!(paquetines %in% installed.packages()[,"Package"])]
if(length(no_instalados)) install.packages(no_instalados)
lapply(paquetines, library, character.only = TRUE)

```

```{r, echo=FALSE, results='hide', include=FALSE, message=FALSE, warning=FALSE}
### DB conections
con <- pub_connect(s3dir = Sys.getenv("S3_DIR"), schema = Sys.getenv("SCHEMA"))
con1 <- prev_connect()
los_queries <- query_dic()

```

```{r, echo=FALSE, results='hide', include=FALSE, message=FALSE, warning=FALSE}
# Funciones

load_query <- function(connection,schema,the_table,columns="*",options=""){
    the_query <- "SELECT %s FROM %s.%s"
    complete <- paste0(the_query," ",options)
    schema    <- deparse(substitute(schema))
    the_table <- deparse(substitute(the_table))
    initial <- RPostgreSQL::dbSendQuery(connection,
                             sprintf(complete,columns,schema,the_table))
}

load_geom <- function(connection,schema,the_table,columns="cve_mun, cve_ent, cve_muni, ", geom_col, col_shape, options=""){
    geom_col <- deparse(substitute(geom_col))
    schema    <- deparse(substitute(schema))
    the_table <- deparse(substitute(the_table))
    col_shape <- deparse(substitute(col_shape))

    the_query <- "SELECT %s FROM %s.%s"
    geom_col_as <- sprintf("ST_AsText(%s) as geom",geom_col)
    columns <- paste0(columns,geom_col_as)
    complete <- paste0(the_query," ",options)

    initial <- RPostgreSQL::dbSendQuery(connection,
                             sprintf(complete,columns,schema,the_table)) %>%
    retrieve_result()

    mun_shp = WKT2SpatialPolygonsDataFrame(initial, geom = geom_col, id = col_shape)
    mun_df <- fortify(mun_shp, region = col_shape)
    names(mun_df)[names(mun_df)=="id"] <- col_shape

    return(mun_df)
}

theme_pub <- function(base_size=12, font=NA){
  txt <- element_text(size = base_size+2, colour = "black", face = "plain")
  bold_txt <- element_text(size = base_size+2, colour = "black", face = "bold")
  
  theme_classic(base_size = base_size, base_family = font) +
    
  theme(plot.title = element_text(size = 30, face = "bold"),
        axis.title.x = element_text(size=20),
        axis.title.y = element_text(size=20),
        axis.text.x = element_text(angle = 45, size=22, hjust = 1),
        axis.text.y = element_text(size=22),
        legend.text = element_text(size=10))
}

quant_labels <- function(variable, no_classes=6){
  quantiles <- quantile(variable, 
                        probs = seq(0, 1, length.out = no_classes + 1),na.rm = TRUE)
  labels <- c()
  for(idx in 1:length(quantiles)){labels <- c(labels, paste0(round(quantiles[idx], 2)," – ", round(quantiles[idx + 1], 2))) }
  labels <- labels[1:length(labels)-1]
  variable_q <- cut(variable, breaks = quantiles,labels = labels, include.lowest = T)
  return(variable_q)
}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Geometría
geom_nal <- load_geom(con1,raw,geom_municipios,geom_col=geom,col_shape=cve_muni)

### Población y Pobreza
## CONEVAL 2015
coneval <- load_table(con1,clean,coneval_municipios) %>% retrieve_result() %>% 
  filter(data_date == "2015-a")
## Intercensal 2015
intercensal_poblacion <- load_table(con1,public,poblacion_intercensal_mun_2015) %>% retrieve_result() %>%
  rename(poblacion_intercensal = poblacion)
## Conapo
conapo <- load_table(con1,raw,conapo_proyecciones_poblacion) %>% retrieve_result() 

poblacion <- left_join(coneval, intercensal_poblacion)

# Cuestionario Único para el Análisis de Programas Sociales (CUAPS)
## Programas
cuaps_programas <- load_table(con1,raw,cuaps_programas) %>% retrieve_result() %>% 
  filter(chr_cve_dependencia == "20") %>% select(cuaps_folio, chr_nombre_programa_cuaps, chr_clave_prespupuestal_pro, 
                                                 obj_gral_prog, obj_esp_prog_1, pob_obj_prog, der_social_edu, 
                                                 der_social_sal, der_social_alim, der_social_viv, der_social_mam, 
                                                 der_social_tra, der_social_segsoc, der_social_nodis, der_social_beco, 
                                                 der_social_ning)
## Componentes
cuaps_componentes <- load_table(con1,raw,cuaps_componentes) %>% retrieve_result() %>% 
  select(cuaps_folio, id_componente, nombre_componente, id_apoyo, 
         nombre_apoyo, descr_apoyo,
         indic_a, indic_b, indic_c, indic_d, indic_e, indic_f, 
         indic_g, indic_h, indic_i, indic_j, indic_k, indic_l, 
         indic_m, indic_n, indic_o, indic_p, indic_q, indic_r, 
         indic_s, indic_t, tem_apoyo)
## Componentes Agregado
cuaps_componentes_g <- cuaps_componentes %>% 
  select(cuaps_folio, indic_a, indic_b, indic_c, indic_d, indic_e, indic_f, 
         indic_g, indic_h, indic_i, indic_j, indic_k, indic_l, 
         indic_m, indic_n, indic_o, indic_p, indic_q, indic_r, 
         indic_s, indic_t) %>% group_by(cuaps_folio) %>%
  summarise_all(sum)

cuaps <- left_join(cuaps_programas, cuaps_componentes_g, by="cuaps_folio")
cuaps

## Beneficios
catalogo_beneficios <- csv_s3()
colnames(catalogo_beneficios) <- c("cdbeneficio","nbbeneficio")

```



# Análisis por número de beneficiarios únicos

```{r, echo=FALSE, message=FALSE, warning=FALSE}
query <- "SELECT cvemuni, count(distinct newid), sum(nuimpmonetario) as monto
              FROM athena_pub.pub_nominal
              WHERE anio=2017 AND cast(newid as integer) < 500000000 AND cddependencia='20' 
              GROUP BY cvemuni"

c(monto_anual_municipal,los_queries) := load_or_run(con,query,los_queries)
colnames(monto_anual_municipal) <- c("cve_muni","num_beneficiarios", "cuenta")

dinero_mun_validos <- monto_anual_municipal %>%
  left_join(poblacion) %>%
  mutate(ben_entre_pob_total = num_beneficiarios/poblacion_intercensal) %>%
  arrange(cve_muni)

municipios_nal <- geom_nal %>%
  left_join(dinero_mun_validos)

municipios_nal$valor <- quant_labels(municipios_nal$ben_entre_pob_total)

plot1 <- ggplot() +
  geom_polygon(data = municipios_nal, aes(long, lat, group=group, fill=valor))+
  labs(title="Tasa de beneficiarios únicos por municipio (SEDESOL)", fill="Número de Beneficiarios")+
  scale_fill_brewer(na.value="grey")+
  coord_fixed()
plot2 <- qplot(municipios_nal$ben_entre_pob_total, geom="histogram")  + xlab("Tasa de Cobertura") 


# Por año
query <- "SELECT anio, count(distinct newid), sum(nuimpmonetario) as monto
              FROM athena_pub.pub_nominal
              WHERE cast(newid as integer) < 500000000 AND cddependencia='20' 
              GROUP BY anio"

c(monto_anual_municipal_por_año,los_queries) := load_or_run(con,query,los_queries)
colnames(monto_anual_municipal_por_año) <- c("anio","num_beneficiarios", "cuenta")

ggplot(monto_anual_municipal_por_año, aes(anio, num_beneficiarios)) + geom_line()

# Por año y municipios
query <- "SELECT anio, cvemuni, count(distinct newid), sum(nuimpmonetario) as monto
              FROM athena_pub.pub_nominal
              WHERE cast(newid as integer) < 500000000 AND cddependencia='20' 
              GROUP BY anio, cvemuni"

c(monto_anual_municipal_por_año_m,los_queries) := load_or_run(con,query,los_queries)
colnames(monto_anual_municipal_por_año_m) <- c("anio","cve_muni","num_beneficiarios", "cuenta")
```


# Análisis Nacional por municipios
# Número total de beneficiarios y monto total de beneficios monetarios durante el 2017 (SEDESOL).

```{r, echo=FALSE, message=FALSE, warning=FALSE}
query <- "SELECT count(distinct newid), sum(nuimpmonetario) as monto 
              FROM athena_pub.pub_nominal
              WHERE anio=2017 AND cast(newid as integer) < 500000000 AND cddependencia='20'"

c(monto_anual_2017,los_queries) := load_or_run(con,query,los_queries)
colnames(monto_anual_2017) <- c("Número de Beneficiarios Únicos con newid válido (SEDESOL)","Suma de Importes monetarios")
monto_anual_2017
```



## Ejemplo de análisis por tipo de programa
Se utilizan las siguientes claves
  indic_a	El apoyo reduce la inseguridad alimentaria severa 
  indic_b	El apoyo reduce la inseguridad alimentaria moderada 
  indic_c	El apoyo incrementa el número de viviendas con piso firme de cemento o recubrimiento (laminado, mosaico, madera)
  indic_d	El apoyo incrementa el número de viviendas con techo de losa de concreto o viguetas con bovedilla, terrado con viguería, lámina metálica, asbesto, palma, teja o de calidad superior
  indic_e	El apoyo reduce el número de viviendas con muros de embarro, bajareque, carrizo, bambú, palma, lámina de cartón, metálica, asbesto o material de desecho
  indic_f	El apoyo reduce el hacinamiendo en la vivienda
  indic_g	El apoyo incrementa el número de viviendas que obtienen agua dentro de sus muros o su terreno
  indic_h	El apoyo incrementa el número de viviendas con drenaje conectado a la red pública o a una fosa séptica
  indic_i	El apoyo incrementa el número de viviendas con energía eléctrica obtenida del servicio público, de panel solar o de otra fuente o planta particular
  indic_j	El apoyo reduce el número de viviendas que usan leña o carbón para cocinar o calentar los alimentos y no cuentan con chimenea
  indic_k	El apoyo incrementa el número de personas con acceso a los servicios de salud a través del Seguro Popular, instituciones públicas de seguridad social o servicios médicos privados
  indic_l	El apoyo reduce el número de personas de 3 a 15 años que no cuentan con la educación básica obligatoria y no asisten a un centro de educación formal
  indic_m	El apoyo incrementa el número de personas con primaria completa (nacidas antes de 1982)
  indic_n	El apoyo incrementa el número de personas con secundaria completa (nacidas a partir de 1982 y mayores de 15 años)
  indic_o	El apoyo incrementa el número de personas asalariadas con servicio médico, incapacidad y AFORE
  indic_p	El apoyo incrementa el número de personas trabajadoras no asalariadas o independientes con acceso a servicio médico, como prestación laboral o por contratación voluntaria, y que cuenta con SAR o AFORE
  indic_q	El apoyo incrementa el número de personas en edad de jubilación (65 años o más) que tiene acceso a la seguridad social a través de algún programa social de pensiones para adultos mayores
  indic_r	El apoyo incrementa el número de hogares con ingreso corriente total per cápita mayor al costo de la canasta básica completa
  indic_s	El apoyo incrementa el número de hogares cuyo ingreso corriente total per cápita es mayor que el costo de la canasta básica alimentaria
  indic_t	Ninguno de los indicadores anteriores
```{r, echo=FALSE, message=FALSE, warning=FALSE}
cves <- cuaps %>% dplyr::filter(indic_a>0 | indic_b>0) %>% select(chr_clave_prespupuestal_pro) %>%  
  filter(chr_clave_prespupuestal_pro!="S070",chr_clave_prespupuestal_pro!= "S053") %>%  pull() %>%
  paste(collapse="', '" ) 

query <- glue::glue("SELECT cvemuni, sum(nuimpmonetario) as monto, count(distinct newid) as beneficiarios 
              FROM athena_pub.pub_nominal 
              WHERE cdprograma IN ('{cves}') AND anio=2017 AND cast(newid as integer) < 500000000 AND cddependencia='20' 
              GROUP BY cvemuni")

c(monto_20_mun_validos,los_queries) := load_or_run(con,query,los_queries)
head(monto_20_mun_validos)
colnames(monto_20_mun_validos) <- c("cve_muni", "cuenta", "num_beneficiarios")

monto_20_mun_validos_ <- monto_20_mun_validos %>%
  left_join(poblacion) %>%
  mutate(ben_pobla=cuenta/poblacion_intercensal,
         ben_entre_pob_total = num_beneficiarios/poblacion_intercensal,
         ben_ic_ali = num_beneficiarios/ic_ali_num) %>%
  arrange(cve_muni)

municipios_nal <- geom_nal %>%
  left_join(monto_20_mun_validos_)

### Número de beneficiarios por municipio.
municipios_nal <- municipios_nal %>% mutate(num_beneficiarios_q = if_else(condition = ben_ic_ali > 1, NA_real_, ben_ic_ali))
municipios_nal$num_beneficiarios_q <- quant_labels(municipios_nal$num_beneficiarios_q)
  

ggplot() +
  geom_polygon(data = municipios_nal, aes(long, lat, group=group, fill=num_beneficiarios_q))+
  labs(title="Tasa de cobertura por carencia y programas relacionados", fill="Número de Beneficiarios")+
  scale_fill_brewer(na.value="grey") +
  coord_fixed()
```






# Obtener la suma de benficiarios únicos por el grupo de programas.
```{r}
 
# Ver tipos de prog
dinero_mun_validos <- beneficiarios_muni %>% select_(.dots = cves)  %>% 
  mutate(sum_all = rowSums(select_if(., is.numeric), na.rm = TRUE))



  left_join(intercensal_poblacion) %>%
  mutate(ben_pobla=cuenta/poblacion,
         ben_entre_pob_total = num_beneficiarios/poblacion) %>%
  arrange(cve_muni)

geom_nal <- load_geom(con1,raw,geom_municipios,geom_col=geom,col_shape=cve_muni)

municipios_nal <- geom_nal %>%
  left_join(dinero_mun_validos)


dinero_mun_validos %>% select(cve_muni, ben_pobla, 
                              ben_entre_pob_total)


```

